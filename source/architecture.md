title: 服務器架構總覽
---

既然Screeps是一個為程序員設計的游戲, 你可能會對它服務器端怎麼工作感興趣. 對於我們來說, 我們也想把這個項目的一些高級架構透露出來.

## 重中之重

*   服務器端使用的軟件有 [Node.js](https://nodejs.org/en/) 8.9.3, [MongoDB](http://mongodb.org) 3, [Redis](http://redis.io/) 3.
*   我們在服務器端寫了 20k 行的 JS 代碼
*   運行時計算在 ovh 上的 40 個四核專用服務器上並行完成，使用 160 個 Intel Xeon CPU E3-1231 v3 處理器內核（具有相應數量的節點實例）。
*   每個 shard 的 MongoDB 數據庫都在一台有 24 核心，128GRAM 的機器上運行，每秒處理 30k 的請求。
*   玩家的運行時代碼是在內存中工作，不進行任何硬盤和數據庫請求

## 架構總覽

所有的游戲數據都是儲存在 MongoDB 裡. 每一個游戲對象都是分散的數據庫文檔(表). 它解釋了由數據庫分配的`id`屬性對象的特定視圖。

每一個游戲中的 tick 都是被 Redis 上的特殊同步代碼控制的. 一個 tick 有兩個階段:

1.  **階段1：解析代碼**
2.  **階段2：執行代碼**

下面是一張階段處理流程圖:

![](img/architecture_stage1.png)

![](img/architecture_stage2.png)

每一個階段都會創建一個任務隊列。第一階段的任務是執行所有活躍玩家的腳本，而第二階段是處理游戲世界的房間。隊列存儲為一個 redis 列表，每個任務都由單獨的計算機單獨處理。

每個 tick 開始時會生成一個列表，其中列出了所有活躍的玩家，這些玩家被放入隊列中以處理他們的游戲腳本。所有服務器從隊列接收任務，請求玩家需要的數據庫數據，並啟動他或她的游戲腳本的運算處理，收集各種游戲對象的命令。當隊列淨空後，第二階段開始。所有活動的命令都被放入隊列，運行時服務器開始處理每個房間中對象的命令。（通俗點講，第一階段只會把所有檢測到的活躍玩家的代碼解析出來，看看哪些需要在第二階段執行，第二階段去執行這些代碼）

盡管第二階段的不同房間和第一階段的不同玩家被分別並行處理，但並行處理的數量嚴格和 cpu 的數量對應。一個房間和一個玩家由一個核心同步處理，排除了各種其他條件。

兩個階段完成後，就形成了一定數量的更改數據庫中游戲對象的請求。 這些要求在第二階段結束後[在bulk裡得到了執行](https://docs.mongodb.org/manual/core/bulk-write-operations/)。 MongoDB 3 使用了新的儲存引擎[WiredTiger](http://www.wiredtiger.com/) 根據文檔級的並發性，它允許利用數據庫服務器上多個並行線程的優勢。 當整個數據庫操作完成後, 整個系統開始執行下一個tick的操作.

數據庫對象更新是唯一需要硬盤訪問的操作。在數據庫服務器上，磁盤刷新每分鐘只執行一次，不會影響根本不使用磁盤的運行時服務器（它們上沒有磁盤）。運行時服務器接收游戲對象和`內存`對象的就緒數據，這些數據甚至在任務啟動之前就加載到RAM中。所有有用的工作都是由運行時服務器的cpu核心來完成的，這些cpu核心在tick的第一階段即計算階段被玩家「租用」。

## 服務器擴展

該系統的設計允許在兩個級別上輕松擴展：

*   當數據庫上的負載增加時 (例如： 玩家們在 shard 上更加活躍), 我們可以選擇增加 WiredTiger 的 CPU 數或增加更多的 shard (每一個 shard 都有自己的數據庫).
*   當玩家計算所產生的 cpu 總負載的增加時，我們可以添加更多的運行時服務器來執行這些計算。在它們啟動後的一分鐘內，它們就可以從 redis 隊列接收和處理任務。

## 玩家腳本運行環境

Node.JS 的 [`vm`](https://nodejs.org/api/vm.html) 庫在計算游戲腳本階段執行任務時使用. 每個節點實例進程都啟動一個單獨的 fork，該 fork 不能訪問其父進程。在啟動後，fork 會立即向數據庫發出一個預先請求，以獲取計算所需的數據。 然後它為用戶創建一個 context 並執行 [`vm.runInContext`](https://nodejs.org/api/vm.html#vm_vm_runincontext_code_contextifiedsandbox_options). context 會保存在 fork 中以備將來使用，這允許您在腳本中重復使用 `global` 對象和 `require` 緩存。 而且，編譯[緩存腳本代碼](http://v8project.blogspot.com.by/2015/07/code-caching.html)可以加快之後的代碼編譯速度。

![](img/architecture_run.png)

盡管 `runincontext` 是特定於每個玩家的代碼執行超時才會被調用的，但它並不總是能夠在某些工作負載類型下優雅地完成腳本執行。如果出現這種情況，則在超時時終止整個 fork 而不是 vm。這個過程中的所有玩家 context 都會消失，然後從頭開始重新創建。

未來，我們計劃開源所有服務器端系統的代碼，讓您在自己的機器上可以啟動 Screeps 進行模擬並研究。
